# 50% Манипуляции с DOM {#50}

А теперь я буду долго и нудно рассказывать о том, как с помощью jQuery можно изменять DOM-дерево на странице, т.е. добавлять и удалять элементы. Но чего это я? Глава в действительности не будет объёмной :)

Начнём с создания элементов для последующей работы с ними. [Документация](http://api.jquery.com/jQuery/) нам заботливо сообщает, что тут всё просто:

```javascript
var $myDiv = $('<div id="my" class="some"></div>');
```

Этот пример вполне рабочий, да вот только производительностью он блистать не будет, ведь внутри будет всё это разбираться с помощью метода «jQuery.parseHTML()», который совсем не быстрый. Но мы можем помочь парсеру, если атрибуты элемента будем передавать вторым параметром:

```javascript
var $myDiv = $('<div>', {'id':'my', 'class':'some'});
```

Можем сделать ещё проще:

```javascript
var $myDiv = $('<div>').attr({'id':'my', 'class':'some'});
```

И этот способ будет работать капельку быстрее. Но почему? Для того, чтобы ответить на данный вопрос, загляните в код jQuery, в самую главную функцию «init()». В её коде можно найти алгоритм разбора предыдущего примера:

1.  Парсим строку, и создаём DOM-элемент в jQuery-обёртке
2.  Заходим в **цикл** обработки переданных параметров:
    1.  Проверяем, а нет ли функции у нашего элемента с таким названием
    2.  Если нет, то устанавливаем атрибут элемента, используя метод «.attr()»

Выводы делайте сами, гдe мы тут время потеряли :)

Ну и напоследок опишу самый быстрый способ, который я часто использую:

```javascript
var myDiv = document.createElement('div');

myDiv.id = 'my';
myDiv.className = 'some';
```

Да, это «чистый» JavaScript, но как по мне – в данном случае он не менее удобен любых фреймворков. И вот вам домашнее задание – оптимизируйте такой скрипт:

```javascript
$('<div id="my"><div id="precious">Ring</div></div>');
```

Все необходимые нам методы собраны в одном разделе документации – [Manipulation](http://api.jquery.com/category/manipulation/). С некоторыми из них мы уже познакомились, и осталось совсем чуть-чуть:

`after(content)` — вставляет контент после каждого элемента из выборки, т.е. если вы встречаете строку `$("p").after("<hr/>")`, читайте её как «после каждого параграфа будет вставлена линия»

`insertAfter(element)` — вставляет элементы из выборки после каждого элемента переданного в качестве аргумента, т.е. если вы встречаете строку `$("<hr/>").insertAfter("p")` – читайте её как «линия будет вставлена после каждого параграфа»

> _— Хм, а я разницы не увидел! — тут всё легко, присмотритесь:_
  ```javascript
$("опорный элемент").after("что добавляем после него?")
$("что добавляем").insertAfter("после какого элемента?")
```

`before(content)` — вставляет контент перед каждым выбранным элементом

`insertBefore(element)` — вставляет элементы из выборки перед каждым элементом, переданным в качестве аргумента

`append(content)` — вставляет контент в конец каждого элемента из выборки, т.е. строку кода `$("p").append("<hr/>")` следует читать как «в конец каждого параграфа будет добавлена линия»

`appendTo(element)` — вставляет выбранный контент в конец каждого элемента, переданного в качестве аргумента: `$("<hr/>").appendTo("p")` — «линия будет добавлена в конец каждого параграфа»

> _Опять про разницу:_
  ```javascript
$("опорный элемент")._append_("что туда дописываем?")
$("что дописываем")._appendTo_("в какой элемент?")
```

`prepend(content)` — вставляет контент в начало каждого элемента из выборки

`prependTo(element)` — вставляет выбранный контент в начало каждого элемента, переданного в качестве аргумента

Так, с этим кусочком документации вроде как разобрались. Опять же, почувствуйте разницу перечисленных методов, ведь дальше будут ещё:

`replaceWith(content)` – заменяет найденные элементы новым

`replaceAll(target)` – вставляет контент взамен найденному
  ```javascript
$("что-то находим").replaceWith("на что меняем")
$("что вставляем").replaceAll("вместо чего")
```

`wrap(element)` – оборачивает каждый найденный элемент новым элементом; т.е. мы конфеты из коробки заворачиваем в фантики

`wrapAll(element)` – оборачивает найденные элементы новым элементом; мы берём пучок конфет и заворачиваем в один большой фантик

`wrapInner(element)` – оборачивает контент каждого найденного элемента новым элементом; берём конфеты, каждую распаковываем, заворачиваем в свой фантик, и сверху заворачиваем в родной фантик

`unwrap()` – удаляет родительский элемент у найденных элементов; фантики прочь!

`clone(withDataAndEvents)` – клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий

`detach()` – удаляет элемент из DOM, но при этом сохраняет все данные о нём в jQuery; следует использовать, если надо лишь временно удалить элемент

`empty()` – удаляет текст и дочерние DOM-элементы

`remove()` – насовсем удаляет элемент из DOM

`html()` – возвращает HTML заданного элемента

`html(newHtml)` – заменяет HTML в заданном элементе

`text()` – возвращает текст заданного элемента; если внутри элемента будут другие HTML-теги, то вернётся сборная солянка из текста всех элементов

`text(newText)` – заменяет текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к [HTML entities](http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%B5%D0%BC%D0%BE%D0%BD%D0%B8%D0%BA%D0%B8_%D0%B2_HTML):

  ```javascript
$("div").text("Some <strong>text</strong>");

// Some &lt;strong&gt;text&lt;/strong&gt;
```

Переварили? Хорошо, теперь настал черёд методов, которые работают с размерами и знают координаты элементов:

> _Но прежде, чем продолжить, хотелось бы освежить в памяти информацию о вычислении высоты и ширины блочных элементов ;)_

`offset()` – возвращает позицию DOM-элемента относительно document, данные будут получены в виде объекта: «{ top: 10, left: 30 }»

`offset({ top: 10, left: 30 })` – устанавливает расположение DOM-элемента по указанным координатам

`position()` – возвращает позицию DOM-элемента относительно родительского элемента

`height()` – возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, то вернётся первый; значение, в отличие от метода «css('height')», возвращается без указания единиц измерения

`height(height)` — устанавливает высоту всех элементов в выборке; если значение высоты передано без указания единиц измерения, то это будут пиксели («px»)

  ```javascript
// в качестве памятки, взято из мануала
$(window).height();   // высота окна
$(document).height(); // высота HTML документа
```

`width()` и `width(width)` – ведут себя аналогично методу «.height()», но работают с шириной элемента

> _Методы «.height()» и «.width()» **не изменяют** своего поведения в зависимости от выбранной блочной модели, т.е. они всегда возвращают параметры области внутри margin, padding и border элемента._

`innerHeight()` и `innerWidth()` – возвращают, соответственно, высоту и ширину элемента, включая «padding»

`outerHeight()` и `outerWidth()` – возвращают высоту и ширину элемента, включая «padding» и «border»

`outerHeight(true)` и `outerWidth(true)` – возвращают высоту и ширину элемента, включая «padding», «border» и «margin»

Для наглядности различий между методами «.height()», «.innerHeight()» и «.outerHeight()» я создал страничку [height.html](http://anton.shevchuk.name/book/code/height.html), а ещё переделал несколько картинок из официальной документации в одну полноценную иллюстрацию:

![блочная модель](/assets/img/box.png)

Ну и последняя пара методов:

`scrollLeft()` – возвращает значение «проскролленности» по горизонтали для первого элемента из выборки

`scrollLeft(value)` – устанавливает значение горизонтального скролла для каждого элемента из выборки

`scrollTop()` – возвращает значение «проскролленности» по вертикали для первого элемента из выборки

`scrollTop(value)` – устанавливает значение вертикального скролла для каждого элемента из выборки

> _Значения «scrollTop» и «scrollLeft» поддаются анимации и не работают для спрятанных элементов DOM._

Методов реально много, я и сам не всегда помню что и для чего (особенно это касается wrap-семейства), так что не утруждайте себя запоминанием всего перечисленного, главное помнить, что таковые имеются, и держать под рукой [документацию](http://api.jquery.com/category/manipulation/).

## Оптимизируем выборки

Ну, перво-наперво, вам следует запомнить, что

**_результаты поиска не кэшируются — каждый раз, запрашивая элементы по селектору, вы инициируете поиск элементов снова и снова_**

Взглянув на алгоритм работы Sizzle сходу напрашиваются несколько советов об оптимизации по работе с выборками:

1.  Сохранять результаты поиска (исходя из постулата выше):

// было

$(&quot;a.button&quot;).addClass(&quot;active&quot;);

/* ... */

$(&quot;a.button&quot;).click(function(){ /* ... */ });

// стало

var $button = $(&quot;a.button&quot;);

$button.addClass(&quot;active&quot;);

/* ... .*/

$button.click(function(){ /* ... */ });

_Правильная IDE о подобных вещах знает, и будет вам время от времени подсказывать ;)_

1.  Использовать цепочки вызовов (что по сути аналогично первому правилу):

// было

$(&quot;a.button&quot;).addClass(&quot;active&quot;);

$(&quot;a.button&quot;).click(function(){ /* ... */ });

// стало

$(&quot;a.button&quot;).addClass(&quot;active&quot;)

.click(function(){ /* ... */ });

1.  Использовать «context» (это такой второй параметр при выборе по селектору):

// было

$(&quot;.content a.button&quot;);

// стало

$(&quot;a.button&quot;, &quot;.content&quot;);

$(&quot;.content&quot;).find(&quot;a.button&quot;,); // чуток быстрее

1.  Разбивать запрос на более простые составные части, используя «context», и сохранять промежуточные данные:

// было

$(&quot;.content a.button&quot;);

$(&quot;.content h3.title&quot;);

// стало

var $content = $(&quot;.content&quot;)

$content.find(&quot;a.button&quot;);

$content.find(&quot;h3.title&quot;);

1.  Использовать более «съедобные» селекторы, дабы помочь методу «.querySelectorAll()», т.е. если у вас нет уверенности в правильности написания селектора, или вы сомневаетесь в том, что все браузеры поддерживают необходимый CSS-селектор, то лучше разделить «сложный» селектор на несколько более простых:

// было

$(&quot;.content div input:disabled&quot;);

// стало

$(&quot;.content div&quot;).find(&quot;input:disabled&quot;);

1.  Не использовать jQuery, а работать с «native» функциями JavaScript&#039;а

_Есть ещё один пункт – выбирать самый быстрый селектор из возможных, но тут без хорошего багажа знаний не обойтись, так что дерзайте, пробуйте и присылайте ваши примеры._

Для наглядности лучше всего взглянуть на сравнительный тест [sizzle.html](http://anton.shevchuk.name/book/code/sizzle.html) (данный тест был изначально разработан Ильёй Кантором для [мастер-класса по JavaScript и jQuery](http://javascript.ru/mk))

_Маленькая хитрость от создателей jQuery – запросы по id элемента не доходят до Sizzle, а скармливаются «document.getElementById()» в качестве параметра:_

_$(&quot;#content&quot;) -&gt; document.getElementById(&quot;content&quot;);_

### Примеры оптимизаций {#-0}

Выбор по идентификатору элемента — самый быстрый из возможных, старайтесь использовать оный:

// внутри одна регулярочка + getElementById()

$(&quot;#content&quot;)

// а вот так ещё быстрее

$(document.getElementById(&quot;content&quot;))

// но экономия незначительна

// а удобство использования стремится к нулю

Селектор «div#content» работает на порядок медленнее, нежели поиск лишь по идентификатору «#content», но и он имеет право на существование в случае, если ваш скрипт используется на нескольких страницах, а логика требует лишь обрабатывать поведение для элемента &lt;div&gt;. Данный селектор можно представить в двух вариантах:

// getElementById() + фильтрация

$(&quot;#content&quot;).filter(&quot;div&quot;);

// оставляем как есть и надеемся на QuerySelectorAll()

$(&quot;div#content&quot;);

В результате [тестирования](http://jsperf.com/div-id) получаем следующий расклад:

*   пример с использованием «.filter()» работает быстрее в браузерах Chrome, Firefox и IE9.0+
*   оба способа работают наравне в браузерах IE8.0 и мобильном Safari
*   второй пример работает в два раза быстрее в последних версиях Opera

Выводы делаем сами.
# 30% События {#30}

Прежде чем приступить к прочтению данной главы, стоит определиться, что же из себя представляют события web-страницы. Так вот, события – это любые действия пользователя, будь то ввод данных с клавиатуры, проматывание страницы или передвижения мышки, и, конечно же, «клики».

_А ещё существуют события, создаваемые скриптами, и их обработчики – триггеры и хэндлеры, но о них чуть позже._

jQuery работает практически со всеми событиями в JavaScript'е, приведу список оных с небольшими пояснениями:

`change` — изменение значения элемента (значение при потери фокуса отличается от начального значения при получении фокуса)

`click` — клик по элементу (порядок событий: «mousedown» → «mouseup» → «click»)

`dblclick` — двойной щелчок мышки

`resize` — изменение размеров элементов

`scroll` — скроллинг элемента

`select` — выбор текста для «input[type=text]» и «textarea»

`submit` — отправка формы

`focus` — фокус на элементе; актуально для «input[type=text]», но в современных браузерах работает и с другими элементами

`blur` — фокус ушёл с элемента; актуально только для элементов «input[type=text]» — срабатывает при клике по другому элементу на странице или по событию клавиатуры (к примеру переключение по tab'у)

`focusin` — фокус на элементе; данное событие срабатывает на предке элемента, для которого произошло событие «focus»

`focusout` — фокус ушёл с элемента; данное событие срабатывает на предке элемента, для которого произошло событие «blur»

`keydown` — нажатие клавиши на клавиатуре

`keypress` — удержание клавиши на клавиатуре, последовательность «keydown → keypress → keyup»

`keyup` — отжатие клавиши на клавиатуре

`mousedown` — нажатие клавиши мыши

`mouseup` — отжатие клавиши мыши

`mousemove` — движение курсора

`mouseenter` — наведение курсора на элемент; не срабатывает при переходе фокуса на дочерние элементы

`mouseleave` — вывод курсора из элемента; не срабатывает при переходе фокуса на дочерние элементы

`mouseover` — наведение курсора на элемент

`mouseout` — вывод курсора из элемента

_Опробовать события можно на примере с [событиями мышки](http://anton.shevchuk.name/book/code/events.mouse.html) и [элементами формы](http://anton.shevchuk.name/book/code/events.form.html). Для большинства событий существуют «shorthand» методы, так, для отслеживания «click» можно использовать «.click()» :)_

Вызов большинства из перечисленных событий можно эмулировать непосредственно из самого скрипта:
```javascript
$("#menu li a").click()

// или используя метод trigger
$("#menu li a").trigger("click")

```

Теперь стоит рассказать немного и об обработчиках событий, для примера возьму код строкой выше и слегка его модифицирую:

```javascript
$("#menu li a").click(function(event){
    alert("Hello!")
})
```


Теперь, кликнув по ссылке, вы увидите приветствие, и после закрытия оного браузер перейдет по ссылке, указанной в атрибуте «href». Но это не совсем то, что мне хотелось – надо было лишь вывести текст и никуда не уходить. Ага, для этого стоит отменить действие по умолчанию:

```javascript
$("#menu li a").click(function(event){
    alert("Hello!");
    event.preventDefault();
})
```

Теперь перехода нет, т.к. метод «event.preventDefault()» предотвращает данное действие. Но вот если кто-то повесит ещё один обработчик на само меню?

```javascript
$("#menu").click(function(event){
    alert("Menu!");
})
```

В результате мы получим два сообщения, но почему? Если у вас возникает подобный вопрос, значит, вы ещё не знакомы с тем, как обрабатываются события. Попробую кратенько дать вводную. Когда вы кликаете на элементе в DOM-дереве, то происходит «погружение» события – т.е. вначале все родительские элементы могут обработать «клик», и лишь потом он доберётся до элемента, по которому был совершён. Но и это ещё не всё. Затем событие начинает проделывать обратный путь – «всплывает», давая тем самым второй шанс родительским элементам обработать событие.

_Но не так всё гладко — у нас же есть «бессмертный» IE, который принципиально не работает с «погружением», поэтому все решили идти по пути наименьшего сопротивления и обрабатывают события лишь на этапе «всплытия»._

_Рекомендую к прочтению статью «[Всплытие и перехват](https://learn.javascript.ru/event-bubbling)» из уже упомянутого учебника Кантора_

Хорошо, вроде бы понятно, теперь вернёмся к нашему примеру, и попытаемся понять что же у нас происходит. Есть обработчик клика на ссылку и обработчик для меню с этой ссылкой. При клике на ссылку срабатывает обработчик события на ссылке, и затем событие всплывает до меню, и срабатывает его обработчик события «click». Но это не совсем желаемый результат, и для борьбы с подобным вредительством необходимо останавливать «всплытие» событий:

```javascript
$("#menu li a").click(function(event){
    alert("Hello!");
    event.preventDefault();
    event.stopPropagation();
})
```

Для ускорения разработки в jQuery есть быстрый способ вызова этих двух методов за раз:

```javascript
$("#menu li a").click(function(event){
    return false; // вот это он :)
})
```

Теперь у вас есть достаточный багаж знаний, чтобы легко манипулировать событиями на странице. Хотя я добавлю ещё немного — для того, чтобы сработал лишь ваш обработчик события, можно использовать метод «event.stopImmediatePropagation()»:

```javascript
$("#menu li a").click(function(event){ // ваш обработчик события
    alert("Hello!"); // он избранный
    event.stopImmediatePropagation(); // он должен остаться только один
    return false;
})

$("#menu li a").click(function(event){ // чужой обработчик событий
    alert("Hello again!"); // он делает всё неправильно
    return false;
})
```

В данном примере при клике на ссылке будет выведено лишь одно сообщение. И да, порядок имеет значение.

# 30% События {#30}

Прежде чем приступить к прочтению данной главы, стоит определиться, что же из себя представляют события web-страницы. Так вот, события – это любые действия пользователя, будь то ввод данных с клавиатуры, проматывание страницы или передвижения мышки, и, конечно же, «клики».

_А ещё существуют события, создаваемые скриптами, и их обработчики – триггеры и хэндлеры, но о них чуть позже._

jQuery работает практически со всеми событиями в JavaScript&#039;е, приведу список оных с небольшими пояснениями:

change — изменение значения элемента (значение при потери фокуса отличается от начального значения при получении фокуса)

click — клик по элементу (порядок событий: «mousedown» → «mouseup» → «click»)

dblclick — двойной щелчок мышки

resize — изменение размеров элементов

scroll — скроллинг элемента

select — выбор текста для «input[type=text]» и «textarea»

submit — отправка формы

focus — фокус на элементе; актуально для «input[type=text]», но в современных браузерах работает и с другими элементами

blur — фокус ушёл с элемента; актуально только для элементов «input[type=text]» — срабатывает при клике по другому элементу на странице или по событию клавиатуры (к примеру переключение по tab&#039;у)

focusin — фокус на элементе; данное событие срабатывает на предке элемента, для которого произошло событие «focus»

focusout — фокус ушёл с элемента; данное событие срабатывает на предке элемента, для которого произошло событие «blur»

keydown — нажатие клавиши на клавиатуре

keypress — удержание клавиши на клавиатуре, последовательность «keydown → keypress → keyup»

keyup — отжатие клавиши на клавиатуре

mousedown — нажатие клавиши мыши

mouseup — отжатие клавиши мыши

mousemove — движение курсора

mouseenter — наведение курсора на элемент; не срабатывает при переходе фокуса на дочерние элементы

mouseleave — вывод курсора из элемента; не срабатывает при переходе фокуса на дочерние элементы

mouseover — наведение курсора на элемент

mouseout — вывод курсора из элемента

_Опробовать события можно на примере с_ [_событиями мышки_](http://anton.shevchuk.name/book/code/events.mouse.html) _и_ [_элементами формы_](http://anton.shevchuk.name/book/code/events.form.html)_. Для большинства событий существуют «shorthand» методы, так, для отслеживания «click» можно использовать «.click()» :)_

Вызов большинства из перечисленных событий можно эмулировать непосредственно из самого скрипта:

&lt;script&gt;

$(&quot;#menu li a&quot;).click()

// или используя метод trigger

$(&quot;#menu li a&quot;).trigger(&quot;click&quot;)

&lt;/script&gt;

Теперь стоит рассказать немного и об обработчиках событий, для примера возьму код строкой выше и слегка его модифицирую:

$(&quot;#menu li a&quot;).click(function(event){

alert(&quot;Hello!&quot;)

})

Теперь, кликнув по ссылке, вы увидите приветствие, и после закрытия оного браузер перейдет по ссылке, указанной в атрибуте «href». Но это не совсем то, что мне хотелось – надо было лишь вывести текст и никуда не уходить. Ага, для этого стоит отменить действие по умолчанию:

$(&quot;#menu li a&quot;).click(function(event){

alert(&quot;Hello!&quot;);

event.preventDefault();

})

Теперь перехода нет, т.к. метод «event.preventDefault()» предотвращает данное действие. Но вот если кто-то повесит ещё один обработчик на само меню?

$(&quot;#menu&quot;).click(function(event){

alert(&quot;Menu!&quot;);

})

В результате мы получим два сообщения, но почему? Если у вас возникает подобный вопрос, значит, вы ещё не знакомы с тем, как обрабатываются события. Попробую кратенько дать вводную. Когда вы кликаете на элементе в DOM-дереве, то происходит «погружение» события – т.е. вначале все родительские элементы могут обработать «клик», и лишь потом он доберётся до элемента, по которому был совершён. Но и это ещё не всё. Затем событие начинает проделывать обратный путь – «всплывает», давая тем самым второй шанс родительским элементам обработать событие.

_Но не так всё гладко — у нас же есть «бессмертный» IE, который принципиально не работает с «погружением», поэтому все решили идти по пути наименьшего сопротивления и обрабатывают события лишь на этапе «всплытия»._

_Рекомендую к прочтению статью «_[_Всплытие и перехват_](https://learn.javascript.ru/event-bubbling)_» из уже упомянутого учебника Кантора_

Хорошо, вроде бы понятно, теперь вернёмся к нашему примеру, и попытаемся понять что же у нас происходит. Есть обработчик клика на ссылку и обработчик для меню с этой ссылкой. При клике на ссылку срабатывает обработчик события на ссылке, и затем событие всплывает до меню, и срабатывает его обработчик события «click». Но это не совсем желаемый результат, и для борьбы с подобным вредительством необходимо останавливать «всплытие» событий:

$(&quot;#menu li a&quot;).click(function(event){

alert(&quot;Hello!&quot;);

event.preventDefault();

event.stopPropagation();

})

Для ускорения разработки в jQuery есть быстрый способ вызова этих двух методов за раз:

$(&quot;#menu li a&quot;).click(function(event){

return false; // вот это он :)

})

Теперь у вас есть достаточный багаж знаний, чтобы легко манипулировать событиями на странице. Хотя я добавлю ещё немного — для того, чтобы сработал лишь ваш обработчик события, можно использовать метод «event.stopImmediatePropagation()»:

$(&quot;#menu li a&quot;).click(function(event){ // ваш обработчик события

alert(&quot;Hello!&quot;); // он избранный

event.stopImmediatePropagation(); // он должен остаться только один

return false;

})

$(&quot;#menu li a&quot;).click(function(event){ // чужой обработчик событий

alert(&quot;Hello again!&quot;); // он делает всё неправильно

return false;

})

В данном примере при клике на ссылке будет выведено лишь одно сообщение. И да, порядок имеет значение.
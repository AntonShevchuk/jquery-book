# 50% Манипуляции с DOM {#50-dom}

А теперь я буду долго и нудно рассказывать о том, как с помощью jQuery можно изменять DOM дерево на странице, т.е. добавлять и удалять элементы, но чего это я, глава в действительности не будет объёмной :)

Начнём с создания элементов для последующей работы с ними, [документация](http://api.jquery.com/jQuery/) нам заботливо сообщает, что тут всё просто:

var $myDiv = $('<div id="my" class="some"></div>')

Этот пример вполне рабочий, да вот только производительностью он блистать не будет, ведь внутри будет всё это разбираться с помощью метода «jQuery.parseHTML()», который совсем не быстрый. Но мы можем помочь парсеру если атрибуты элемента будем передавать вторым параметром:

var $myDiv = $('<div>', {'id':'my', 'class':'some'})

Можем сделать ещё проще:

var $myDiv = $('<div>').attr({'id':'my', 'class':'some'});

И этот способ будет работать даже быстрее (ну совсем капельку), но почему? Для того, чтобы ответить на данный вопрос – загляните в код jQuery, в самую главную функцию «init()», в её коде можно найти алгоритм разбора предыдущего примера:

1.  Парсим строку, и создаём DOM элемент в jQuery обёртке
2.  Заходим в **цикл** обработки переданных параметров:
    1.  Проверяем, а нет ли функции у нашего элемента с таким названием
    2.  Если нет, то устанавливаем атрибут элемента используя метод «.attr()»

Выводы делайте сами, гдe мы тут время потеряли :)

Ну и на последок опишу самый быстрый способ, который я часто использую:

var myDiv = document.createElement('div');

myDiv.id = 'my';

myDiv.className = 'some';

Да, это и есть «чистый» JavaScript, но как по мне – в данном случае он не менее удобен любых фреймворков. И вот вам домашнее задание – оптимизируйте такой скрипт:

$('<div id="my"><div id="precious">Ring</div></div>')

_Выполняйте тут, бумага стерпит:_

Все необходимые нам методы собраны в одном разделе документации – [Manipulation](http://api.jquery.com/category/manipulation/), с некоторыми из них мы уже познакомились, и осталось совсем чуть-чуть:

after(_content_) — вставляет контент после каждого элемента из выборки, т.е. если вы встречаете строку «$("p").after("<hr/>")», читайте её как «после каждого параграфа будет вставлена линия»

insertAfter(_element_) — вставляет элементы из выборки после каждого элемента переданного в качестве аргумента, т.е. если вы встречаете строку «$("<hr/>").insertAfter("p")» – читайте её как «линия будет вставлена после каждого параграфа»

_— Хм, а я разницы не увидел! — тут всё легко, присмотритесь:_

_$("после чего добавляем").after("что добавляем")_

_$("что добавляем").insertAfter("после чего добавляем")_

before(_content_) — вставляет контент перед каждым выбранным элементом

insertBefore(_element_) — вставляет элементы из выборки перед каждым элементом переданным в качестве аргумента

append(_content_) — вставляет контент в конец каждого элемента из выборки, т.е. строку кода «$("p").append("<hr/>")», следует читать как «в конец каждого параграфа будет добавлена линия»

appendTo(_element_) — вставляет выбранный контент в конец каждого элемента переданного в качестве аргумента: «$("<hr/>").appendTo("p")» — «линия будет добавлена в конец каждого параграфа»

_Опять про разницу:_

_$("куда добавляем")._append_("что добавляем")_

_$("что добавляем")._appendTo_("куда добавляем")_

prepend(_content_) — вставляет контент в начало каждого элемента из выборки

prependTo(_element_) — вставляет выбранный контент в начало каждого элемента переданного в качестве аргумента

Так, с этим кусочком документации вроде как разобрались, опять же – почувствуйте разницу перечисленных методов, ведь дальше будут ещё:

replaceWith(_content_) – заменяет найденные элементы новым

replaceAll(_target_) – вставляет контент в замен найденному

_$("что-то находим")._replaceWith_("на что меняем")_

_$("что вставляем")._replaceAll_("вместо чего")_

wrap(_element_) – оборачиваем каждый найденный элемент новым элементом, т.е. мы конфеты из коробки заворачиваем в фантики

wrapAll(_element_) – оборачивает найденные элементы новым элементом, мы берём все конфеты, и заворачиваем в один большой фантик

wrapInner(_element_) – оборачивает контент каждого найденного элемента новым элементом, берём конфеты, убираем фантики, заворачиваем в свой фантик, и сверху заворачиваем в родной фантик

unwrap() – удаляет родительский элемент у найденных элементов, фантики вон

clone(_withDataAndEvents_) – клонирует выбранные элементы, для дальнейшей вставки копий назад в DOM, позволяет так же копировать и обработчики событий

detach() – удаляет элемент из DOM, но при этом сохраняет все данные о нём в jQuery, следует использовать, если надо удалить элемент, а потом вернуть его обратно

empty() – удаляет текст и дочерние DOM элементы

remove() – удаляет элемент из DOM, насовсем

html() – вернёт HTML заданного элемента

html(_newHtml_) – заменит HTML в заданном элементе

text() – вернёт текст заданного элемента, если внутри элемента будут другие HTML тэги, то вернётся сборная солянка из текста всех элементов

text(_newText_) – заменит текст внутри выбранных элементов, при попытке вставить таким образом HTML, будет получен текст, где тэги будут приведены к [HTML entities](http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%B5%D0%BC%D0%BE%D0%BD%D0%B8%D0%BA%D0%B8_%D0%B2_HTML):

_$("div")._text_("Some <strong>text</strong>")_

_>> Some &amp;lt;strong&amp;gt;text&amp;lt;/strong&amp;gt;_

Переварили? Хорошо, теперь настал черёд методов, которые работают с размерами, и знают координаты элементов:

_Но прежде чем продолжить, хотелось бы освежить в памяти_

_информацию_

_о вычислении высоты и ширины блочных элементов ;)_

offset() – вернёт позицию DOM элемента относительно document'а, данные будут получены в виде объекта: «{ top: 10, left: 30 }»

offset(_{ top: 10, left: 30 }_) – устанавливаем расположение DOM элемента по указанным координатам

position() – вернёт позицию DOM элемента относительно родительского элемента

height() – возвращает высоту элемента за вычетом отступов и границ; если у нас несколько элементов в выборке, вернётся первый; значение, в отличии от метода «css('height')», возвращается без указания единиц измерения

height(_height_) — устанавливает высоту всех элементов в выборке, если значение высоты передано без указания единиц измерения, то это будут «px»

// в качестве памятки, взято из мануала

$(window).height(); // высота окна

$(document).height(); // высота HTML документа

width() и width(_width_) – ведут себя аналогично методу «.height()», но работают с шириной элемента

_Методы «.height()» и «.width()»_ **_не изменяют_** _своего поведения в зависимости от выбранной блочной модели, т.е. они всегда возвращают параметры области внутри margin, padding и border'а элемента._

innerHeight() и innerWidth() – вернут соответственно высоту и ширину элемента, включая «padding»

outerHeight() и outerWidth() – вернут высоту и ширину элемента, включая «padding» и «border»

outerHeight(_true_) и outerWidth(_true_) – высота и ширина, включая «padding», «border» и «margin»

Для наглядности различий между методами «.height()», «.innerHeight()» и «.outerHeight()» я создал страничку [height.html](http://anton.shevchuk.name/book/code/height.html), а ещё переделал несколько картинок из официальной документации в одну полноценную иллюстрацию:

Рисунок — блочная модель

Ну и последняя пара методов:

scrollLeft() – возвращает значение «проскроленности» по горизонтали первого элемента из выборки

scrollLeft(_value_) – устанавливает значение горизонтального скрола для каждого элемента из выборки

scrollTop() – возвращает значение «проскроленности» по вертикали первого элемента из выборки

scrollTop(_value_) – устанавливает значение вертикального скрола для каждого элемента из выборки

_Значение «scrollTop» и «scrollLeft» поддаются анимации и не работают для спрятанных элементов DOM_

Методов реально много, я и сам не всегда помню что и для чего (особенно это касается wrap-семейства), так что не утруждайте себя запоминанием всего перечисленного, главное помнить что таковые имеются и держать под рукой [документацию](http://api.jquery.com/category/manipulation/)
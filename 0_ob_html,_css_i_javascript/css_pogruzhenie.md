## CSS. Погружение {#css}

Этот раздел будет полезен начинающим верстальщикам и тем, кто захочет сделать чуть больше, нежели вывод окна сообщения по клику.

### О форматировании {#codestyle}

Нет, я не властен над собой, и таки приведу в качестве примера CSS-форматирование, которое я использую:
```css
/* Header */
header {
    margin-bottom: 16px;
    font-weight: 400;
}

header h1 {
    color: #999;
}

header p {
    font-size: 1.4em;
    margin-top: 0;
}
```

Почему это хорошо:

* такой CSS легко читается
* есть идентификатор начала блока (можно быстро найти необходимую часть даже в очень большом CSS файле используя поиск по метке «* header»)
* подобное форматирование явно указывает на вложенность элементов
* и можно легко проследить наследование свойств

Я не настаиваю на своём варианте, но хотелось, чтобы вы приняли на вооружение один из многих стандартов форматирования и всегда следовали ему.

_Когда станете матёрыми front-end разработчиками, то познаете всю силу CSS-препроцессоров, а пока слушайте и запоминайте._

### Именование классов и идентификаторов {#naming-convention}

Я уже затрагивал эту тему, когда рассказывал о релевантности HTML, так вот – имена классов могут быть даже такими:
«b-service-list__column b-service-list__column_right» и это будет круто, и «must have» – но лишь в рамках действительно
больших проектов. Собственно, чего я распинаюсь? Дам [исходную точку](https://ru.bem.info/methodology/) для изучения – информации там ещё на одну книгу ;)

> _Обязательно ознакомьтесь с [принципами БЭМ](https://ru.bem.info/methodology/) – это полезно для расширения кругозора и прокачки скиллов._

> _Чуть не забыл - никогда не ровняйтесь на классы которые вы встретите в [Twitter Bootstrap](https://getbootstrap.com/)! Большинство из них следует использовать только совместно с [SASS препроцессором](http://sass-lang.com/) (это я про классы вида `pt-X`, `m-X` и тому подобные)_

### О цветах {#css-colors}

В WEB используется цветовая модель [RGB](http://www.w3.org/TR/css3-color/), я не открою вам Америку, если расскажу, 
что красный цвет можно записать не только как «red», но и ещё несколькими способами:

```css
p { color: red }

p { color: #ff0000 }

p { color: #f00 } /* сокращённая запись, экономит 3 байта */

p { color: rgb(255, 0, 0) }
```

_Теперь вы без запинки должны назвать цвета `#f00`, `#0f0`, `#00f`, а те, у кого по рисованию было «отлично», 
назовут и `#ff0`, `#0ff` и `#f0f` ;)_

С появлением CSS3, указывая цвет, мы также можем задать значение α-канала, т.е. прозрачность:

```css
p { color: rgba(255, 0, 0, 1) }   /* обычный текст */

p { color: rgba(255, 0, 0, 0.5) } /* полупрозрачный текст */
```

Ещё одна примочка CSS3 – это возможность использования цветовой модели [HSL](http://www.w3.org/TR/2010/PR-css3-color-20101028/) 
(hue saturation lightness – тон, насыщенность и светлота) и [HSLA](http://www.w3.org/TR/css3-color/) (HSL + α-канал):

```css
p { color: hsl( 0, 100%, 50%) }   /* красный */

p { color: hsl(120, 100%, 50%) }  /* зелёный */

p { color: hsl(240, 100%, 50%) }  /* синий */

p { color: hsla( 0, 100%, 50%, 0.5) } /* полупрозрачный красный */
```

Для перевода из HSL в RGB существует простой алгоритм, но пока не стоит им себя грузить.

>_Да кто этим HSL пользуется? Не морочьте себе голову!_

Тем, кого вопрос со смешанием каналов RGB поставил в тупик, наглядное руководство:

### Блочные и строчные элементы {#block-and-inline}

_Опять я буду ссылаться на чей-то учебник — на этот раз от Ивана Сагалаева —_ [_http://softwaremaniacs.org/blog/category/primer/_](http://softwaremaniacs.org/blog/category/primer/)_, и пусть вас не смущают даты написания статей — они повествуют об основах и актуальность не потеряют ещё очень долго_

Возможно, вы ещё не знаете, но HTML теги делятся на блочные (block-тип) и строчные (inline-тип). Блочными элементами называют те, которые отображаются как прямоугольник, они занимают всю доступную ширину и их высота определяется содержимым. Блочные теги по умолчанию начинаются и заканчиваются новой строкой — это `<div>`, `<h1>` и собратья, `<p>` и другие.

Если хотите, чтобы ваш HTML оставался валидным, следите за тем, чтобы блочные элементы не располагались внутри строчных элементов. Внутри строчных тегов может быть либо текст, либо другие строчные элементы.

> _Одна из самых часто встречаемых ошибок, это оборачивание заголовка в ссылку: `<a href="#"><h1>Название статьи</h1></a>`.
Не допускайте подобные промахи. Хотя если мы ориентируемся на HTML5 – то тег `<a>` теперь может быть блочным элементом, и приведённый пример будет валидным.
Ага, вот такой я непоследовательный._

По теме:

* [Inline Elements List and What’s New in HTML5](http://www.tutorialchip.com/tutorials/inline-elements-list-whats-new-in-html5/)
* [HTML5 Block Level Elements: Complete List](http://www.tutorialchip.com/tutorials/html5-block-level-elements-complete-list/)
* [Раскладка в CSS: поток](http://softwaremaniacs.org/blog/2005/08/27/css-layout-flow/)

### О размерах блочных элементов {#size}

Ещё хотел отдельно остановиться на вычислении ширины и высоты блочных элементов, ведь тут есть один нюанс. По умолчанию высота и ширина элементов считаются без учёта толщины границ и внутренних отступов, т.е. как-то так:

Эта блочная модель называется «content-box», и вот в CSS3 появилась возможность изменять блочную модель, указывая атрибут «box-sizing». Отлично, теперь мы можем выбирать между двумя значениями «content-box» и «border-box». Первый я уже описал, а вот второй вычисляет высоту и ширину включая внутренние отступы и толщину границ:

_Такая блочная модель была свойственна IE6 в «quirks mode»_

Полезные статьи по теме:

* [Блочные элементы](http://htmlbook.ru/content/blochnye-elementy)
* [Встроенные элементы](http://htmlbook.ru/content/vstroennye-elementy)

### Плавающие элементы {#float}

Я бы хотел ещё рассказать о CSS свойстве «float», но боюсь, рассказ будет долгим и утомительным. Кратенько: если вы указываете элементу свойство «float», то:

* наш элемент будет смещён по горизонтали, и «прилипнет» к указанному краю родительского элемента
* если это был блочный элемент, то теперь он не будет занимать всю ширину родительского элемента и освободит место
* если следом идут блочные элементы, то они займут его место
* если следом идут строчные элементы, то они будут обтекать наш элемент со свободной стороны

Это поведение «по умолчанию», а как это выглядит в живую можно посмотреть на примере [css.float.html](http://anton.shevchuk.name/book/code/css.float.html). Тут главное понимать происходящее и уметь управлять, если, конечно, вы хотите хоть чуть-чуть научиться верстать :)

Жизненно необходимая информация для верстальщиков:

* [Раскладка в CSS: float](http://softwaremaniacs.org/blog/2005/12/01/css-layout-float/)

### Позиционирование {#position}

Дам лишь вводную по «position» – у него бывает лишь четыре значения:

* `static` — положение дел «по умолчанию», блоки ложатся друг за другом, сверху вниз, по порядку, без отклонений
* `absolute` — блок позиционируется согласно заданным координатам
* `fixed` — похоже на «absolute», с той лишь разницей, что блок не будет скроллиться
* `relative` — такой блок можно сдвигать относительно места, где он расположен, ну и все внутренние «абсолютные» блоки будут использовать данный элемент как точку отсчета при позиционировании по координатам

Для самостоятельного изучения:

* [Раскладка в CSS: позиционирование](http://softwaremaniacs.org/blog/2005/08/03/css-layout-positioning/)

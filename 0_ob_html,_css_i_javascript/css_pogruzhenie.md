## CSS. Погружение {#css}

Этот раздел будет полезен начинающим верстальщикам и тем, кто захочет сделать чуть больше, нежели вывод окна сообщения по клику.

### О форматировании

Нет, я не властен над собой, и таки приведу в качестве примера CSS-форматирование, которое я использую:

/*header*/

header {

margin-bottom: 16px;

font-weight: 400;

}

header h1 {

color: #999;

}

header p {

font-size: 1.4em;

margin-top: 0;

}

/*/header*/

Почему это хорошо:

*   такой CSS легко читается
*   есть идентификатор начала и конца блока (можно быстро найти необходимую часть даже в очень большом CSS файле используя поиск по метке «*header»)
*   подобное форматирование явно указывает на вложенность элементов
*   и можно легко проследить наследование свойств

Я не настаиваю на своём варианте, но хотелось, чтобы вы приняли на вооружение один из многих стандартов форматирования и всегда следовали ему.

_Когда станете матёрыми front-end разработчиками, то познаете всю силу CSS-препроцессоров, а пока слушайте и запоминайте._

### Именование классов и идентификаторов {#-0}

Я уже затрагивал эту тему, когда рассказывал о релевантности HTML, так вот – имена классов могут быть даже такими: «b-service-list__column b-service-list__column_right» и это будет круто, и «must be» – но лишь в рамках действительно больших проектов. Собственно, чего я распинаюсь? Дам исходную точку для изучения – информации там ещё на одну книгу ;):

*   «Что такое БЭМ» — [[https://ru.bem.info/methodology/](https://ru.bem.info/methodology/)]

Обязательно ознакомьтесь с принципами БЭМ – это полезно для расширения кругозора и прокачки скиллов

### О цветах {#-1}

В WEB используется цветовая модель [RGB](http://www.w3.org/TR/css3-color/), я не открою вам Америку, если расскажу, что красный цвет можно записать не только как «red», но и ещё несколькими способами:

p { color: red }

p { color: #ff0000 }

p { color: #f00 } /* сокращённая запись, экономит 3 байта */

p { color: rgb(255, 0, 0) }

_Теперь вы без запинки должны назвать цвета #f00, #0f0, #00f, а те, у кого по рисованию было «отлично», назовут и #ff0, #0ff и #f0f ;)_

С появлением CSS3, указывая цвет, мы также можем задать значение α-канала, т.е. прозрачность:

p { color: rgba(255, 0, 0, 1) } /* обычный текст */

p { color: rgba(255, 0, 0, 0.5) } /* полупрозрачный текст */

Ещё одна примочка CSS3 – это возможность использования цветовой модели [HSL](http://www.w3.org/TR/2010/PR-css3-color-20101028/) (hue saturation lightness – тон, насыщенность и светлота) и [HSLA](http://www.w3.org/TR/css3-color/) (HSL + α-канал):

p { color: hsl( 0, 100%, 50%) } /* красный */

p { color: hsl(120, 100%, 50%) } /* зелёный */

p { color: hsl(240, 100%, 50%) } /* синий */

p { color: hsla( 0, 100%, 50%, 0.5) } /* полупрозрачный красный */

Для перевода из HSL в RGB существует простой алгоритм, но пока не стоит им себя грузить.

_Да кто этим HSL пользуется? Не морочьте себе голову!_

Тем, кого вопрос со смешанием каналов RGB поставил в тупик, наглядное руководство:

### Блочные и строчные элементы {#-2}

_Опять я буду ссылаться на чей-то учебник — на этот раз от Ивана Сагалаева —_ [_http://softwaremaniacs.org/blog/category/primer/_](http://softwaremaniacs.org/blog/category/primer/)_, и пусть вас не смущают даты написания статей — они повествуют об основах и актуальность не потеряют ещё очень долго_

Возможно, вы ещё не знаете, но HTML теги делятся на блочные (block-тип) и строчные (inline-тип). Блочными элементами называют те, которые отображаются как прямоугольник, они занимают всю доступную ширину и их высота определяется содержимым. Блочные теги по умолчанию начинаются и заканчиваются новой строкой — это &lt;div&gt;, &lt;h1&gt; и собратья, &lt;p&gt; и другие.

Если хотите, чтобы ваш HTML оставался валидным, следите за тем, чтобы блочные элементы не располагались внутри строчных элементов. Внутри строчных тегов может быть либо текст, либо другие строчные элементы.

_Одна из самых часто встречаемых ошибок, это оборачивание заголовка в ссылку: &lt;a href=&quot;#&quot;&gt;&lt;h1&gt;Название статьи&lt;/h1&gt;&lt;/a&gt;._

_Не допускайте подобные промахи._

_Хотя если мы ориентируемся на HTML5 – то тег &lt;a&gt; теперь может быть блочным элементом, и приведённый пример будет валидным._

_Ага, вот такой я непоследовательный._

По теме:

*   «Inline Elements List and What’s New in HTML5»

[[http://www.tutorialchip.com/tutorials/inline-elements-list-whats-new-in-html5/](http://www.tutorialchip.com/tutorials/inline-elements-list-whats-new-in-html5/)]

*   «HTML5 Block Level Elements: Complete List»

[[http://www.tutorialchip.com/tutorials/html5-block-level-elements-complete-list/](http://www.tutorialchip.com/tutorials/html5-block-level-elements-complete-list/)]

*   «Раскладка в CSS: поток»

[[http://softwaremaniacs.org/blog/2005/08/27/css-layout-flow/](http://softwaremaniacs.org/blog/2005/08/27/css-layout-flow/)]

### О размерах блочных элементов {#-3}

Ещё хотел отдельно остановиться на вычислении ширины и высоты блочных элементов, ведь тут есть один нюанс. По умолчанию высота и ширина элементов считаются без учёта толщины границ и внутренних отступов, т.е. как-то так:

Эта блочная модель называется «content-box», и вот в CSS3 появилась возможность изменять блочную модель, указывая атрибут «box-sizing». Отлично, теперь мы можем выбирать между двумя значениями «content-box» и «border-box». Первый я уже описал, а вот второй вычисляет высоту и ширину включая внутренние отступы и толщину границ:

_Такая блочная модель была свойственна IE6 в «quirks mode»_

Полезные статьи по теме:

*   «Блочные элементы»

[[http://htmlbook.ru/content/blochnye-elementy](http://htmlbook.ru/content/blochnye-elementy)]

*   «Встроенные элементы»

[[http://htmlbook.ru/content/vstroennye-elementy](http://htmlbook.ru/content/vstroennye-elementy)]

### Плавающие элементы {#-4}

Я бы хотел ещё рассказать о CSS свойстве «float», но боюсь, рассказ будет долгим и утомительным. Кратенько: если вы указываете элементу свойство «float», то:

*   наш элемент будет смещён по горизонтали, и «прилипнет» к указанному краю родительского элемента
*   если это был блочный элемент, то теперь он не будет занимать всю ширину родительского элемента и освободит место
*   если следом идут блочные элементы, то они займут его место
*   если следом идут строчные элементы, то они будут обтекать наш элемент со свободной стороны

Это поведение «по умолчанию», а как это выглядит в живую можно посмотреть на примере [css.float.html](http://anton.shevchuk.name/book/code/css.float.html). Тут главное понимать происходящее и уметь управлять, если, конечно, вы хотите хоть чуть-чуть научиться верстать :)

Жизненно необходимая информация для верстальщиков:

*   «Раскладка в CSS: float»

[[http://softwaremaniacs.org/blog/2005/12/01/css-layout-float/](http://softwaremaniacs.org/blog/2005/12/01/css-layout-float/)]

### Позиционирование {#-5}

Дам лишь вводную по «position» – у него бывает лишь четыре значения:

static — положение дел «по умолчанию», блоки ложатся друг за другом, сверху вниз, по порядку, без отклонений

absolute — блок позиционируется согласно заданным координатам

fixed — похоже на «absolute», с той лишь разницей, что блок не будет скроллиться

relative — такой блок можно сдвигать относительно места, где он расположен, ну и все внутренние «абсолютные» блоки будут использовать данный элемент как точку отсчета при позиционировании по координатам

Для самостоятельного изучения:

*   «Раскладка в CSS: позиционирование»

[[http://softwaremaniacs.org/blog/2005/08/03/css-layout-positioning/](http://softwaremaniacs.org/blog/2005/08/03/css-layout-positioning/)]